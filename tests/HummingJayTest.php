<?php
namespace HummingJay;

class Foo extends Resource{
    // Mini-resource used to test routing, instantiating resources, etc.
    public $title = 'Foo!';
    public $description = "I am Foo!";

    public function post($server){
        if($server->requestData){
            $server->addResponseData(["reply"=>"The {$server->requestData->animal} goes quack."]);
        }
        return $server;
    }
} 



/**
 * Generated by PHPUnit_SkeletonGenerator on 2015-06-19 at 21:48:05.
 */
class HummingJayTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var HummingJay
     */
    protected $object;
    protected $server;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        $this->server = new Server();
        $this->object = new HummingJay(null, $this->server);
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
    }



    /**
     * @covers HummingJay\HummingJay::parseRouteString
     */
    public function testRoute()                                            
    {
        $routes = $this->object->parseRouteString("/foo - \\HummingJay\\Foo");

        $this->server->uri = '/foo';
        $this->server->method = "OPTIONS";
        $this->object->route($routes);
        $this->assertEquals(
            200,
            $this->server->httpStatus,
            'If routing was successful, we should have a 200 OK status'
        );
        $this->assertEquals(
            'Foo!',
            $this->server->makeResponseBody()['hypermedia']['title'],
            'If routing was successful (OPTIONS /foo) , the hypermedia title will be set'
        );


        $this->server->uri = '/notexists';
        $this->object->route($routes);
        $this->assertEquals(
            404,
            $this->server->httpStatus,
            'A non-matching URI should return a 404'
        );
        $this->assertContains(
            'not found',
            $this->server->makeResponseBody()['hypermedia']['description'],
            'The hypermedia description should contain an error message for a 404.'
        );


        $routes = $this->object->parseRouteString("/bad - BadClass");
        $this->server->uri = '/bad';
        $this->object->route($routes);
        $this->assertEquals(
            500,
            $this->server->httpStatus,
            'An http 500 status should be returned when the URI is good, but the resource is not'
        );
    }

    /**
     * @covers HummingJay\HummingJay::parseRouteString
     */
    public function testParseRouteString()                                            
    {
        $this->assertArrayHasKey(
            "/books",
            $this->object->parseRouteString("/books - Demo\\BooksCollection") , 
            "Test a single line route string"
        );

        $this->assertArrayHasKey(
            "/cars",
            $this->object->parseRouteString("/books - D \n/cars - C") , 
            "Test two line route string with UNIX line ending"
        );

        $this->assertArrayHasKey(
            "/cars",
            $this->object->parseRouteString("/books - D \r\n/cars - C"),
            "Test two line route string with Windows line ending"
        );

        $this->assertArrayHasKey(
            "/books",
            $this->object->parseRouteString("/books - D"),
            "Test single line route string."
        );
        $this->assertEquals(
            'none',
            $this->object->routeStringError,
            'error property is \'none\' if all went well'
        );

        $this->object->parseRouteString("/uri/but/no/class");
        $this->assertNotEquals(
            'none',
            $this->object->routeStringError,
            'error should be set to something other than  \'none\' if there was a problem with the route string'
        );
    }

    

    /**
     * @covers HummingJay\HummingJay::matchUri
     */
    public function testMatchUri()
    {
        $routes = $this->object->parseRouteString("/books - D \r\n/cars - C");

        $this->assertEquals(
            null, 
            $this->object->matchUri($routes, '/cats'), 
            "Test if a URI that doesn't match returns null"
        );

        $this->assertEquals(
            'D', 
            $this->object->matchUri($routes, '/books')["classname"], 
            "Test if a URI match returns classname"
        );

        $this->assertEquals(
            'C', 
            $this->object->matchUri($routes, '/cars')["classname"], 
            "Test if a URI match returns classname on a second item"
        );

        $routes = $this->object->parseRouteString("/books/{bid}/reviews/{rid} - Review");
        $matchedResource = $this->object->matchUri($routes, '/books/13/reviews/45'); 

        $this->assertEquals('13', $matchedResource['params']['bid'], "URI match has first param");
        $this->assertEquals('45', $matchedResource['params']['rid'], "URI match has second param");

    }



    /**
     * @covers HummingJay\HummingJay::makeResource
     */
    public function testMakeResource()
    {
        $this->assertEquals(
            null, 
            $this->object->makeResource("NoGoats"), 
            "Class that doesn't exist returns null"
        );

        $this->assertInstanceOf(
            "HummingJay\Foo", 
            $this->object->makeResource("HummingJay\Foo"),
            "Check if a Foo object is returned."
        );

    }


    public function testSystem()
    {
        // As much as possible (without an actual web server)
        // test the outcomes of real-world usage of
        // HummingJay from instantiation to (simulated) output:

        // 1. Test Data Round-Trip
        $server1 = new Server();
        $server1->uri = '/test1';
        $server1->method = 'POST';
        $server1->rawRequestData = '{"animal":"duck"}';
        $server1->decodeJson(); // have to manually call because we're in test environment
        $test1 = new HummingJay('/test1 - \\HummingJay\\Foo', $server1);
        $headers1 = $test1->sentResponse["headers"];
        $response_data1 = json_decode($test1->sentResponse["body"]);
        $this->assertContains('HTTP/1.0 200 OK', $headers1, "Status should indicate request was good");
        $this->assertEquals("The duck goes quack.", $response_data1->reply, "The response body should have JSON-encoded data proving the input was accepted and used.");

        // 2. Test 404 Error - generated by HummingJay::route()
        $server2 = new Server();
        $server2->uri = '/baduri';
        $test2 = new HummingJay('/test2 - \\HummingJay\\Foo', $server2);
        $headers2 = $test2->sentResponse["headers"];
        $response_data2 = json_decode($test2->sentResponse["body"]);
        $this->assertContains('HTTP/1.0 404 Not Found', $headers2, "Status should be 404 because this is a bad URI");
       
        // 3. Test 500 Error - generated by HummingJay::route()
        $server3 = new Server();
        $server3->uri = '/test3';
        $test3 = new HummingJay('/test3 - BadClassname', $server3);
        $headers3 = $test3->sentResponse["headers"];
        $response_data3 = json_decode($test3->sentResponse["body"]);
        $this->assertContains('HTTP/1.0 500 Internal Server Error', $headers3, "Status should be 500 because the URI is good, but the resource classname isn't");

        // 4. Test 400 Error - generated by Server::decodeJson()
        $server4 = new Server();
        $server4->uri = '/test4';
        $server4->method = 'POST';
        $server4->rawRequestData = '{invalid json}';
        $server4->decodeJson(); // have to manually call because we're in test environment
        $test4 = new HummingJay('/test4 - \\HummingJay\\Foo', $server4);
        $headers4 = $test4->sentResponse["headers"];
        $response_data4 = json_decode($test4->sentResponse["body"]);
        $this->assertContains('HTTP/1.0 400 Bad Request', $headers4, "Status should be 400 because json data was mangled");
        $this->assertContains("syntax_error", $response_data4->json_error, "Response body should contain a json_error explaining the problem");
    
        // 5. Test 405 Error - generated by Resource::callMethod()
        $server5 = new Server();
        $server5->uri = '/test5';
        $server5->method = 'GET';
        $test5 = new HummingJay('/test5 - \\HummingJay\\Foo', $server5);
        $headers5 = $test5->sentResponse["headers"];
        $this->assertContains('HTTP/1.0 405 Method Not Allowed', $headers5, "Status should be 405 because the GET method not supported");

    }

}
